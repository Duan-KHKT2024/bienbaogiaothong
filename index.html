<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Traffic Sign Recognition</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      background-color: #f0f0f0;
      margin: 20px;
      color: #333;
    }
    h1 {
      font-size: 2.5em;
      color: #333;
      margin-bottom: 30px;
    }
    #menu {
      margin-bottom: 30px;
    }
    #menu button {
      padding: 10px 20px;
      font-size: 16px;
      margin: 10px;
      cursor: pointer;
      border: none;
      background-color: #007bff;
      color: #fff;
      border-radius: 5px;
      transition: background-color 0.3s;
    }
    #menu button:hover {
      background-color: #0056b3;
    }
    #controls-container {
      display: none;
      margin-bottom: 30px;
    }
    #webcam-container {
      display: none;
      margin: 20px auto;
      background-color: #fff;
      padding: 15px;
      border-radius: 10px;
      box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.1);
      max-width: 500px;
    }
    #file-container {
      display: none;
      margin: 30px auto;
      padding: 15px;
      background-color: #fff;
      border-radius: 10px;
      box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.1);
      max-width: 500px;
    }
    #file-container input[type="file"] {
      display: none;
    }
    #file-container label {
      cursor: pointer;
      padding: 10px 20px;
      font-size: 16px;
      background-color: #28a745;
      color: #fff;
      border-radius: 5px;
      transition: background-color 0.3s;
    }
    #file-container label:hover {
      background-color: #218838;
    }
    #label-container {
      margin-top: 20px;
      font-size: 1.2em;
    }
    #label-container div {
      margin: 5px;
      padding: 10px;
      background: #007bff;
      color: #fff;
      border-radius: 5px;
      display: inline-block;
      min-width: 100px;
    }
  </style>
</head>
<body>
  <h1>Teachable Machine Traffic Sign Recognition</h1>

  <!-- Menu -->
  <div id="menu">
    <button onclick="showInstructions()">Hướng Dẫn</button>
    <button onclick="selectDevice('computer')">Máy Tính</button>
    <button onclick="selectDevice('phone')">Điện Thoại</button>
    <button onclick="selectDevice('file')">Chọn File Ảnh</button>
  </div>

  <!-- Instructions -->
  <div id="instructions" style="display:none; margin-bottom: 20px;">
    <p>Chọn "Máy Tính" để sử dụng webcam của máy tính. Chọn "Điện Thoại" để sử dụng camera trước hoặc sau của điện thoại. Chọn "Chọn File Ảnh" để tải lên một ảnh từ thiết bị của bạn.</p>
  </div>

  <!-- Controls container -->
  <div id="controls-container">
    <div id="camera-controls" style="display:none;">
      <label for="cameraSelect">Chọn camera:</label>
      <select id="cameraSelect"></select>
      <button type="button" onclick="setupWebcam()">Start Webcam</button>
    </div>
  </div>

  <!-- Container to display the webcam -->
  <div id="webcam-container">
    <button id="captureButton" onclick="captureImage()" style="display:none; margin-top: 20px;">Chụp Hình</button>
    <canvas id="capturedCanvas" style="display:none;"></canvas>
  </div>

  <!-- Allow user to select an image file from computer -->
  <div id="file-container">
    <label for="imageUpload">Chọn một ảnh từ máy</label>
    <input type="file" id="imageUpload" accept="image/*" onchange="predictFromImage()">
  </div>

  <!-- Container to display predictions -->
  <div id="label-container"></div>

  <!-- Include the necessary libraries -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@teachablemachine/image@latest/dist/teachablemachine-image.min.js"></script>

  <script type="text/javascript">
    // Teachable Machine model URL
    const URL = "https://teachablemachine.withgoogle.com/models/fFZnpVlVM/";

    let model, webcam, labelContainer, maxPredictions, currentStream;

    // Load the model and setup the webcam
    async function init() {
        const modelURL = URL + "model.json";
        const metadataURL = URL + "metadata.json";

        try {
          // Load the model and metadata
          model = await tmImage.load(modelURL, metadataURL);
          maxPredictions = model.getTotalClasses();
        } catch (error) {
          console.error("Error loading model: ", error);
          alert("Error loading model. Please check the console for more details.");
        }
    }

    // Show instructions
    function showInstructions() {
      document.getElementById('instructions').style.display = 'block';
    }

    // Select device type
    function selectDevice(device) {
      stopWebcam();
      document.getElementById('webcam-container').style.display = 'none';
      document.getElementById('file-container').style.display = 'none';
      document.getElementById('camera-controls').style.display = 'none';
      document.getElementById('captureButton').style.display = 'none';

      if (device === 'computer') {
        document.getElementById('controls-container').style.display = 'block';
        document.getElementById('camera-controls').style.display = 'block';
      } else if (device === 'phone') {
        document.getElementById('controls-container').style.display = 'block';
        document.getElementById('camera-controls').style.display = 'block';
      } else if (device === 'file') {
        document.getElementById('file-container').style.display = 'block';
      }
    }

    // Stop the webcam stream
    function stopWebcam() {
      if (currentStream) {
        currentStream.getTracks().forEach(track => track.stop());
        currentStream = null;
      }
      if (webcam) {
        webcam.stop();
      }
    }

    // Setup webcam with selected camera
    async function setupWebcam() {
        const cameraSelect = document.getElementById('cameraSelect');
        const cameraId = cameraSelect.value;
        
        stopWebcam();

        const constraints = {
          video: {
            deviceId: cameraId ? { exact: cameraId } : undefined,
            width: 400,
            height: 400
          }
        };

        try {
          currentStream = await navigator.mediaDevices.getUserMedia(constraints);
          if (!webcam) {
            webcam = new tmImage.Webcam(400, 400, false);
          }
          await webcam.setup({ facingMode: 'environment', video: currentStream });
          await webcam.play();
          document.getElementById("captureButton").style.display = 'block';
          document.getElementById("webcam-container").style.display = 'block';
          document.getElementById("webcam-container").appendChild(webcam.canvas);
        } catch (error) {
          console.error("Error accessing webcam: ", error);
        }
    }

    // Capture image from webcam
    function captureImage() {
      const capturedCanvas = document.getElementById("capturedCanvas");
      const ctx = capturedCanvas.getContext("2d");

      // Ensure capturedCanvas has the same size as the webcam canvas
      capturedCanvas.width = webcam.canvas.width;
      capturedCanvas.height = webcam.canvas.height;

      // Draw the current frame from the webcam onto the capturedCanvas
      ctx.drawImage(webcam.canvas, 0, 0);
      capturedCanvas.style.display = 'block';

      // Predict from the captured image
      predictFromCapturedImage(capturedCanvas);
    }

    // Predict from the captured image
    async function predictFromCapturedImage(capturedCanvas) {
      const prediction = await model.predict(capturedCanvas);

      // Display predictions
      labelContainer = document.getElementById("label-container");
      labelContainer.innerHTML = ""; // Clear existing predictions
      for (let i = 0; i < maxPredictions; i++) {
          const classPrediction = `${prediction[i].className}: ${(prediction[i].probability * 100).toFixed(2)}%`;
          labelContainer.appendChild(document.createElement("div")).innerHTML = classPrediction;
      }
    }

    // Predict from an uploaded image
    async function predictFromImage() {
        const imageUpload = document.getElementById('imageUpload');
        const file = imageUpload.files[0];
        if (!file) {
          alert("Vui lòng chọn một ảnh trước.");
          return;
        }

        const img = new Image();
        img.src = URL.createObjectURL(file);
        img.onload = async function () {
          const prediction = await model.predict(img);

          // Display predictions
          labelContainer = document.getElementById("label-container");
          labelContainer.innerHTML = ""; // Clear existing predictions
          for (let i = 0; i < maxPredictions; i++) {
              const classPrediction = `${prediction[i].className}: ${(prediction[i].probability * 100).toFixed(2)}%`;
              labelContainer.appendChild(document.createElement("div")).innerHTML = classPrediction;
          }
        };
    }

    // Initialize model on page load
    window.onload = init;
  </script>
</body>
</html>
